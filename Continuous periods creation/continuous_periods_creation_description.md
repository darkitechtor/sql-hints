# Логическое объединение строк в непрерывные периоды на примере истории трудоустройства сотрудника

## Исходные данные
|Person|Company|Position|start_date|end_date|
|-|-|-|-|-|
|John Doe|Microsoft|Junior Developer|07.06.2012|22.04.2013|
|John Doe|Microsoft|Developer|25.04.2013|30.09.2015|
|John Doe|Google|Middle Developer|01.12.2015|17.02.2017|
|John Doe|Google|Middle Developer|01.01.2018|01.09.2018|
|John Doe|Amazon|Middle Developer|01.10.2018|31.03.2020|
|John Doe|Google|Senior developer|01.04.2020|30.09.2020|
|John Doe|Meta|Senior developer|05.10.2020|19.02.2021|

## Что требуется
Предоставить скомпонованную информацию по истории трудоустройства сотрудника:
1. Если сотрудник переводился между должностями в рамках одной компании, в результате период должен быть непрерывным, даже если периоды не стыкуются. Например, день завершения работы на старой должности - пятница, а день начала на новой - понедельник (строки 1-2).
2. Если у сотрудника был длительный промежуток между записями, относящимися к одной компании, такой период также должен быть непрерывным.</br>Условно считаем, что это "отпуск", т.к. у нас недостаточно данных, чтобы принять иное решение, например, считать, что сотрудник действительно уволился и затем вернулся в ту же компанию или имел в это время иную занятость, данных о которой у нас нет (строки 3-4).
3. Если сотрудник работал в компании А, затем устроился в В/С/..., после чего снова устроился в А, эти периоды работы в А должны отображаться отдельно, так как были разделены иной занятостью (строки 4-6).

## Что ожидается на выходе
|Person|Company|start_date|end_date|
|-|-|-|-|
|John Doe|Microsoft|07.06.2012|30.09.2015|
|John Doe|Google|01.12.2015|01.09.2018|
|John Doe|Amazon|01.10.2018|31.03.2020|
|John Doe|Google|01.04.2020|30.09.2020|
|John Doe|Meta|05.10.2020|19.02.2021|

## Логика решения
1. При помощи оконной функции `LAG` определяем дату начала трудоустройства в кождой из компаний по каждому сотруднику, чтобы иметь точку отсчета:</br>`CASE WHEN [Company] = LAG([Company]) OVER (PARTITION BY [Person] ORDER BY [StartDate]) THEN 0 ELSE 1 END`.
2. Используя в окне функцию `SUM` нарастающим итогом (`ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`), объединяем периоды по вышеописанным правилам:</br>`SUM(employment_start) OVER(PARTITION BY [Person] ORDER BY [start_date] ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)`</br>Это работает следующим образом:</br>- Отсчет начинается с единицы, и первый период, соответственно, получает номер "1".</br>- Если следующая строка продолжает данный период, то к единице прибавляется нуль, а значит, номер периода остается прежним.</br>- Если период сменяется, то его номер увеличивается на единицу.
3. В конце группируем таблицу по необходимым полям (`Person` и `Company`), а также по полю `scope`, содержащему номер группы, определив `MIN([start_date])` и `MAX([end_date])` - даты начала и конца периода соответственно.